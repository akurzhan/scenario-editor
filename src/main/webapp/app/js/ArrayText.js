// Generated by CoffeeScript 1.3.3
(function() {

  window.sirius.ArrayText = {
    slice_and_dice: function(data, delims, convert) {
      var dim, rest_delims,
        _this = this;
      dim = delims.length;
      switch (dim) {
        case 0:
          return this.convert(data);
        case 1:
          if (data.length === 0) {
            return [];
          } else {
            return _.map(data.split(delims[0]), function(s) {
              return convert(s);
            });
          }
          break;
        default:
          rest_delims = delims.slice(1, 1000000);
          return _.map(data.split(delims[0]), function(s) {
            return _this.slice_and_dice(s, rest_delims, convert);
          });
      }
    },
    convert_cell_to_number: function(s) {
      var n;
      n = Number(s);
      if (isNaN(s)) {
        throw "Invalid numeric data in cell: " + s;
      }
      return n;
    },
    convert_cell_to_string: function(s) {
      return s;
    },
    fn_to_convert_cell_from: function(cell_type, object_with_id) {
      switch (cell_type) {
        case "String":
          return this.convert_cell_to_string;
        case "Number":
          return this.convert_cell_to_number;
        default:
          return function(id) {
            return object_with_id[id];
          };
      }
    },
    parse: function(input, delims, cell_type, object_with_id) {
      var convert, data;
      data = String(input);
      convert = this.fn_to_convert_cell_from(cell_type, object_with_id);
      if (convert === null) {
        throw "bad input, cell_type = " + cell_type;
      }
      return this.slice_and_dice(data, delims, convert);
    },
    emit: function(input, delims, indenter) {
      var dim, ind,
        _this = this;
      if (delims == null) {
        delims = null;
      }
      if (indenter == null) {
        indenter = "";
      }
      dim = delims != null ? delims.length : 0;
      ind = "";
      switch (dim) {
        case 0:
          return input.toString();
        case 1:
          return input.join(delims[0]);
        case 2:
          ind = indenter + "  ";
          return ind + _.map(input, function(a) {
            return _this.emit(a, delims.slice(1, 2), indenter);
          }).join(delims[0] + ind);
        case 3:
          ind = indenter + "  ";
          return ind + _.map(input, function(a) {
            return _.map(a, function(a1) {
              return a1.join(delims[2]);
            }).join(delims[1]);
          }).join(delims[0] + ind);
        default:
          return input.toString();
      }
    }
  };

}).call(this);
